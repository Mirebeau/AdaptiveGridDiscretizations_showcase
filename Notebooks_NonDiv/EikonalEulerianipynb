{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Adaptive PDE discretizations on cartesian grids\n",
    "## Volume : Non-divergence form PDEs\n",
    "## Part : Eikonal equations\n",
    "## Chapter : Eulerian schemes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This notebook presents a single pass Eulerian scheme for the Riemannian eikonal equation. It is provided solely for pedagogical purposes.\n",
    "Indeed, let us emphasize that a state of the art C++ implementation, more optimized and versatile, is also provided. It is strongly recommended to use that implementation for any serious application, see [notebook](../Notebooks_FMM/Riemannian.ipynb) and volume [summary](../Notebooks_FMM/Summary.ipynb). "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The purpose of this notebook is to illustrate the theory and implementation principles underlying eikonal equation solvers, in particular the (anisotropic) fast marching method and the fast sweeping method. \n",
    "The PDE to be solved is known as the *Riemannian eikonal equation*, and it involves a Riemannian metric $M : \\Omega \\to S_d^{++}$ on a domain $\\Omega\\subset R^d$. Denoting by $u : \\Omega \\to R^d$ the unkown, the problem is written\n",
    "$$\n",
    "    \\| \\nabla u(x)\\|_{D(x)} = 1\n",
    "$$\n",
    "for all $x \\in \\Omega$, where $D(x) := M(x)^{-1}$. Null boundary conditions, or outflow boundary conditions, are applied on $\\partial \\Omega$. The solution $u$ should be regarded as the arrival times of a front originating from the boundary. Minimal paths toward the boundary, also known as minimal geodesics, can be extracted by solving the ODE\n",
    "$$\n",
    "    \\gamma'(t) := V(\\gamma(t))\n",
    "$$\n",
    "where $V(x) := D(x) \\nabla u(x)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Important ! Note on computation speed.** Because of intrinsic limitations of the Python programming language, and in particular the slow execution of sequential programs, the fast marching eikonal solver implemented in this notebook is extremely slow. In particular it is slower than the global iteration, or the fast sweeping method, also implemented. The fast marching method is here only implemented for pedagogical purposes. Please use the C++ implementation, or some reimplementation of the Python programs below in a compiled language, for any application.\n",
    "\n",
    "**Note on accuracy.** The eikonal equation solver presented below is extremely basic, and presented solely for pedagogical purposes. Two optional techniques, implemented in the c++ version allow to increase accuracy: equation factoring, and a dynamic switch to second order finite differences.\n",
    "\n",
    "**Reference.** The numerical scheme implemented in this notebook is described in the following publication:\n",
    "* Jean-Marie Mirebeau, Jorg Portegies, \"Hamiltonian Fast Marching: A numerical solver for anisotropic and non-holonomic eikonal PDEs\", 2019, IPOL [(link)](https://hal.archives-ouvertes.fr/hal-01778322)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "[**Summary**](Summary.ipynb) of volume Non-Divergence form PDEs, this series of notebooks.\n",
    "\n",
    "[**Main summary**](../Summary.ipynb) of the Adaptive Grid Discretizations \n",
    "\tbook of notebooks, including the other volumes.\n",
    "\n",
    "# Table of contents\n",
    "  * [1. The update operator](#1.-The-update-operator)\n",
    "  * [2. Iteration policies](#2.-Iteration-policies)\n",
    "    * [2.1 Global iteration](#2.1-Global-iteration)\n",
    "    * [2.2 Fast sweeping](#2.2-Fast-sweeping)\n",
    "    * [2.3 Fast marching](#2.3-Fast-marching)\n",
    "  * [3. Anisotropic metric](#3.-Anisotropic-metric)\n",
    "\n",
    "\n",
    "\n",
    "**Acknowledgement.** The experiments presented in these notebooks are part of ongoing research, \n",
    "some of it with PhD student Guillaume Bonnet, in co-direction with Frederic Bonnans.\n",
    "\n",
    "Copyright Jean-Marie Mirebeau, University Paris-Sud, CNRS, University Paris-Saclay"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 0. Importing the required libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys; sys.path.insert(0,\"..\") # Allow import of agd from parent directory (useless if conda package installed)\n",
    "#from Miscellaneous import TocTools; TocTools.displayTOC('EikonalEulerian','NonDiv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys; sys.path.append(\"..\") # Allow import from parent directory\n",
    "from agd import Selling\n",
    "from agd import LinearParallel as lp\n",
    "from agd import FiniteDifferences as fd\n",
    "from agd import AutomaticDifferentiation as ad"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import itertools\n",
    "import heapq\n",
    "import scipy.linalg"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def LInfNorm(a):\n",
    "    return np.max(np.abs(np.array(a)))\n",
    "\n",
    "def as_field(u,shape):\n",
    "    ndim = len(shape)\n",
    "    if u.ndim>=ndim and u.shape[-ndim:]==shape: return u\n",
    "    else: return np.broadcast_to(u.reshape(u.shape+(1,)*ndim), u.shape+shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. The update operator\n",
    "\n",
    "Our discretization of the eikonal equation is based on a decomposition of the inverse tensors to the Riemannian metric. For all $x \\in \\Omega$,\n",
    "$$\n",
    "    D(x) = \\sum_{1 \\leq i \\leq I} \\rho_i(x) e_i e_i^T\n",
    "$$\n",
    "where $\\rho_i(x) \\geq 0$ is a non-negative weight, and $e_i=e_i(x) \\in Z^d$ is an offset, which may depend on the current position $x$.\n",
    "The numerical scheme reads\n",
    "$$\n",
    "    F u (x) := \\sum_{1 \\leq i \\leq I} \\rho_i(x) \\max \\{0,\\frac{u(x)-u(x-h e_i)} h, \\frac{u(x)-u(x+h e_i)} h\\}^2 - 1.\n",
    "$$\n",
    "for all discretization points $x$ in the domain interior. One has to solve $F u \\equiv 0$.\n",
    "\n",
    "**Historical note.**\n",
    "This numerical scheme was introduced by Rouy in 1992, in the case of an isotropic metric: $D(x)$ is proportional to the identity matrix. In that special case, the natural tensor decomposition only uses offsets from the canonical basis. It was observed by Sethian in 1996 that it can be solved in a single pass using the fast marching method. \n",
    "\n",
    "The author, in 2018, generalized the scheme to handle arbitrary anisotropic Riemannian metrics, using adequate methods for tensor decomposition. See the reference in the introduction."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Scheme(u,coefs,offsets,h):\n",
    "    v = np.maximum(0,np.maximum(-fd.DiffUpwind(u, offsets,gridScale=h,padding=np.inf),\n",
    "                                -fd.DiffUpwind(u,-offsets,gridScale=h,padding=np.inf)))\n",
    "    residue = (coefs*np.maximum(0,v)**2).sum(axis=0) - 1.\n",
    "    boundary = np.logical_or.reduce(np.isnan(coefs),axis=0)\n",
    "    return np.where(boundary,0.,residue)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In contrast with the other notebooks of this series, we will not use a Newton method to solve this numerical scheme. Instead, we rely on Gauss-Siedel updates. In other words we solve, pointwise, for $u(x)$ assuming that $u(y)$ is fixed for all $y \\neq x$. These updates are repeated until convergence, following an order in the domain that is discussed below.\n",
    "\n",
    "**Gauss-Siedel update of $u(x)$.** Consider a fixed point $x \\in \\Omega$, and denote, for all $1 \\leq i \\leq I$,\n",
    "$$\n",
    "    v_i := \\min \\{u(x-h e_i), u(x+h e_i)\\}.\n",
    "$$\n",
    "Assume that $v_1 \\leq \\cdots \\leq v_I$, up to sorting these quantities.\n",
    "Then $\\lambda = u(x)$ is the solution to a quadratic equation\n",
    "$$\n",
    "    \\alpha \\lambda^2 - 2 \\beta \\lambda + \\gamma = 0\n",
    "$$\n",
    "where \n",
    "$$\n",
    "    \\alpha := \\sum_{1 \\leq i \\leq J} \\rho_i, \\quad \\beta := \\sum_{1 \\leq i \\leq J} \\rho_i v_i, \\quad \\gamma := -h^2+\\sum_{i \\leq J} \\rho_i v_i^2.\n",
    "$$\n",
    "We denoted by $J$ the unique integer $1 \\leq J \\leq I$ such that  \n",
    "$$\n",
    "    \\lambda \\in [v_J,v_{J+1}],\n",
    "$$\n",
    "with the convention $V_{I+1} = \\infty$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def gtr_silentNaN(a,b):\n",
    "    \"\"\"Compare two values without emitting a warning for NaNs\"\"\"\n",
    "    from numpy import warnings\n",
    "    with np.warnings.catch_warnings():\n",
    "        warnings.simplefilter(\"ignore\")\n",
    "        return a>b\n",
    "    \n",
    "def Update(u,coefs,offsets,h,where=(Ellipsis,)):\n",
    "    \"\"\"Local Gauss-Siedel update for the fast marching algorithm\"\"\"\n",
    "    #Get the values at the neighbors\n",
    "    v = np.minimum(fd.TakeAtOffset(u, offsets,padding=np.inf,where=where),\n",
    "                   fd.TakeAtOffset(u,-offsets,padding=np.inf,where=where))\n",
    "    \n",
    "    u,coefs=u[where],coefs[(slice(None),)+where] # Akin to coefs[:,where]\n",
    "    \n",
    "    v[coefs==0.] = np.inf; \n",
    "    ai=v.argsort(axis=0)\n",
    "    v,coefs = (np.take_along_axis(a,ai,axis=0) for a in (v,coefs))\n",
    "    \n",
    "    # Initialize the variables\n",
    "    result= np.zeros_like(u)\n",
    "    result[v[0]==np.inf]=np.inf # Far points\n",
    "    boundary = np.logical_or.reduce(np.isnan(coefs),axis=0)\n",
    "    result[boundary]=u[boundary] # Apply bc\n",
    "    considered = np.logical_and(v[0]<np.inf, np.logical_not(boundary))    \n",
    "    v[:,np.logical_not(considered)] = np.nan; coefs[:,np.logical_not(considered)] = np.nan\n",
    "    \n",
    "    alpha = coefs[0]\n",
    "    beta  = np.zeros_like(u)\n",
    "    gamma = np.zeros_like(u) - h**2\n",
    "    solution = h/np.sqrt(alpha)\n",
    "    result[considered] = v[0,considered]+solution[considered] # Update from closest neighbor\n",
    "        \n",
    "    # Solve the quadratic equations\n",
    "    for rhoi, vi in zip(coefs[1:],v[1:]-v[0]):\n",
    "        considered = np.logical_and(considered,gtr_silentNaN(np.inf,vi))\n",
    "        if not isinstance(vi,np.ndarray): vi=np.array(vi)\n",
    "        vi[vi==np.inf]=np.nan\n",
    "        \n",
    "        alpha+=rhoi\n",
    "        beta+=rhoi*vi\n",
    "        gamma+=rhoi*vi**2\n",
    "        \n",
    "        delta = beta**2 - gamma*alpha\n",
    "        sdelta = np.sqrt(np.maximum(0.,delta))\n",
    "        considered = np.logical_and(considered,gtr_silentNaN(delta,0)) #delta>0.)\n",
    "\n",
    "        solution = (beta+sdelta)/alpha\n",
    "        considered = np.logical_and(considered,gtr_silentNaN(solution,vi)) #solution>vi)\n",
    "        result[considered]= v[0,considered]+solution[considered]\n",
    "        \n",
    "    return result"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We next define the some problem parameters, in order to test the scheme.\n",
    "As a start, we use an isotropic metric on the square, with a single seed point in the center."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Define the square [-1,1]^2, sampled on a cartesian grid\n",
    "aX0 = np.linspace(-1,1,51); aX1 = aX0\n",
    "gridScale=aX0[1]-aX0[0]\n",
    "X0,X1 = np.meshgrid(aX0,aX1,indexing='ij')\n",
    "\n",
    "# Define the domain, and the problem parameters\n",
    "metric = as_field(np.eye(2),X0.shape)\n",
    "bc=np.full(X0.shape,np.nan)\n",
    "bc[X0.shape[0]//2,X0.shape[1]//2] = 0\n",
    "\n",
    "# Decompose the tensors dual to the Riemannian metric\n",
    "coefs, offsets = Selling.Decomposition(lp.inverse(metric))\n",
    "coefs[:,np.logical_not(np.isnan(bc))] = np.nan"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "#u0=np.where(np.isnan(bc),np.inf,bc)\n",
    "#Update(u0,coefs,offsets,gridScale)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Iteration policies\n",
    "\n",
    "We present three classical iteration policies, applied to for the Gauss-Siedel update implemented in the previous section. The justification of their convergence is based on mathematical properties, referred to as *Monotony* and *Causality*.\n",
    "\n",
    "**Monotony.** Denote by $\\Lambda$ the Gauss-Siedel update operator implemented above. This operator benefits from an important property, known as monotony: for any discrete maps $u,v$\n",
    "$$\n",
    "    u\\leq v \\Rightarrow \\Lambda u \\leq \\Lambda v,\n",
    "$$\n",
    "where $u\\leq v$ means $u(x) \\leq v(x)$ for all points $x\\in X$ of the discretization domain $X$.\n",
    "Monotony is inherited from another property of the numerical scheme $F$, known as degenerate ellipticity: $Fu(x)$ is a non-decreasing function of the finite differences $u(x)-u(y)$, $y \\neq x$.\n",
    "\n",
    "**Iterative methods**\n",
    "Thanks to monotony, and mild additional technical assumptions, basic repeated iteration of the updates over the domain is guaranteed to converge to the numerical scheme solution. Some variants exist in the iteration order, for instance:\n",
    "* *Global iteration.* Set $u(x) \\gets \\Lambda u(x)$ simultaneously for all $x\\in X$.\n",
    "* *Fast sweeping and related methods.* Set $u(x) \\gets \\Lambda u(x)$ simultaneously for all $x$ in a slice of the domain. Iterate slice by slice: left to right, right to left, top to bottom, bottom to top, and then repeat.\n",
    "\n",
    "Iterations are stopped when a stopping criterion is met. If the initialization $u_0$ equals $+\\infty$ in the domain interior, or a sufficiently large value, then one easily shows using monotonicity that the successive iterates obey $u_{n+1} \\leq u_n$. A typicaly stopping criterion is then \n",
    "$$\n",
    "    u_{n+1} \\geq u_n+ \\epsilon,\n",
    "$$\n",
    "where $\\epsilon>0$ is a given tolerance.\n",
    "\n",
    "**Causality.** The Gauss-Siedel update operator corresponding to our numerical scheme benefits from an additional property, known as causality: for any discrete maps $u$ \n",
    "$$\n",
    "    \\Lambda u(x) \\text{ may depend on } u(y) \\text{ only if } u(y) < \\Lambda u(x).\n",
    "$$\n",
    "Causality is inherited from another property of the numerical scheme $F$, also referred to as causality: $Fu(x)$ only depends on the non-negative part of the finite differences $u(x)-u(y)$, $y\\neq x$.\n",
    "Note that, in addition, $u(x)$ may depend on $u(y)$ only if $y$ appears in the stencil of $x$, in other words $y = x\\pm h e_i$ for some $1 \\leq i \\leq I$.\n",
    "\n",
    "**Single pass solution.**\n",
    "Thanks to monotony and causality, and mild additional technical assumptions, the system of equations discretizing the PDE can be solved in a *single pass* over the domain, visiting each point a finite number of times that is prescribed in advance. For that purpose, a variant of Dijkstra's shortest path algorithm is used, known as the fast marching method.\n",
    "\n",
    "In contrast with the iterative methods, the fast marching naturally stops after a finite number of steps."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.1 Global iteration\n",
    "\n",
    "We simultaneously update the unknown function $u$ over all the domain."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "def GlobalIteration(update,u0,args,eps=1e-6,niter_max=200):\n",
    "    u=u0.copy()\n",
    "    for niter in range(niter_max):\n",
    "        u,u_old = update(u,*args),u\n",
    "        if np.all(u+eps>=u_old):\n",
    "            return u,niter\n",
    "    print(\"Iterative method did not reach stopping criterion within iteration budget\")\n",
    "    return u,niter_max"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 76.6 ms, sys: 2.56 ms, total: 79.2 ms\n",
      "Wall time: 78 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "u0=np.where(np.isnan(bc),np.inf,bc)\n",
    "solution,nupdate = GlobalIteration(Update,u0,(coefs,offsets,gridScale))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The number of updates per point `niter` is quite large with this approach, since the front progresses only by one pixel at a time. \n",
    "Therefore `niter` is not far from the domain diameter, measured in pixels.\n",
    "More precisely, `niter` is the length of the longest minimal path in the domain, measured in pixels. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average number of updates per point : 50\n"
     ]
    }
   ],
   "source": [
    "print(\"Average number of updates per point :\", nupdate)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.axis('equal')\n",
    "plt.contourf(X0,X1,solution);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let us check that the system of equations is indeed solved."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Max residue : 1.7985612998927536e-14\n"
     ]
    }
   ],
   "source": [
    "residue = Scheme(solution,coefs,offsets,gridScale)\n",
    "print(\"Max residue :\",LInfNorm(residue))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.2 Fast sweeping\n",
    "\n",
    "In this approach, solution is updated slice after slice, left to right, right to left, top to bottom, bottom to top, etc. On large domains, the number of updates per pixel is smaller than with the global iteration approach."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "def SweepSlices(shape):\n",
    "    \"\"\"Enumerates the slices used in the fast sweeping method.\"\"\"\n",
    "    dim = len(shape)\n",
    "    s=(slice(None),)\n",
    "    for d,n in enumerate(shape):\n",
    "        for x in itertools.chain(range(n),reversed(range(n))):\n",
    "            yield s*d +(x,)+s*(dim-d-1)\n",
    "\n",
    "def SweepIteration(update,u0,args,eps=1e-6,niter_max=100):\n",
    "    u=u0.copy()\n",
    "    for niter in range(niter_max):\n",
    "        u_old=u.copy()\n",
    "        for sl in SweepSlices(u0.shape):\n",
    "            u[sl]=update(u,*args,where=sl)\n",
    "        if np.all(u+eps>=u_old):\n",
    "            return u,niter*2*u0.ndim\n",
    "    print(\"Iterative method did not reach stopping criterion within iteration budget\")\n",
    "    return u,niter_max*2*u0.ndim"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Note on execution time.** For some reason that needs to be clarified, the update of a slice of the domain costs almost as much as the update of the full domain with this Python implementation. (This is possibly an issue with memory management.) As a result, execution time is here much larger than with the global iteration approach. This effect is not encountered in reasonably optimized implementations, possibly written in other languages."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 1.46 s, sys: 7.14 ms, total: 1.47 s\n",
      "Wall time: 1.47 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "u0=np.where(np.isnan(bc),np.inf,bc)\n",
    "solution,nupdate = SweepIteration(Update,u0,(coefs,offsets,gridScale))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In principle, fast sweeping allows to substantially reduce the number of updates per point in comparison with global iteration. This effect is pronounced over large domains, but is not much observed in very small domains as here."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average number of updates per point : 48\n"
     ]
    }
   ],
   "source": [
    "print(\"Average number of updates per point :\", nupdate)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.axis('equal')\n",
    "plt.contourf(X0,X1,solution);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Max residue : 1.7985612998927536e-14\n"
     ]
    }
   ],
   "source": [
    "residue = Scheme(solution,coefs,offsets,gridScale)\n",
    "print(\"Max residue :\",LInfNorm(residue))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.3 Fast marching\n",
    "\n",
    "The fast marching method updates the solution in a very specific order, in a Dijkstra-like fashion, taking advantage of the causality of the numerical scheme.\n",
    "\n",
    "A preliminary step, achieved in the `ReverseNeighbors` routine, is to identify all the *reverse neighbors* of given point $y \\in X$. In other words all $x \\in X$ such that $y = x \\pm h e_i(x)$ for some $1 \\leq i \\leq I$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ReverseNeighbors(shape,offsets):\n",
    "    \"\"\"Reverses a directed graph, defined by offsets on a cartesian grid. \n",
    "    The reverse neighbors for index i are orig[changes[i]:changes[i+1]], \n",
    "    where (orig,changes) is the output.\"\"\"\n",
    "    # Get original and neighbor offset\n",
    "    neigh,inside = fd.OffsetToIndex(shape,offsets)\n",
    "    size = np.prod(shape)\n",
    "    orig = np.broadcast_to(np.arange(size),(neigh.size//size,size)).flatten()\n",
    "    orig,neigh=orig[inside.flatten()],neigh[inside].flatten()\n",
    "\n",
    "    # Sort according to neighbor offset\n",
    "    ind = np.lexsort((orig,neigh))\n",
    "    orig,neigh=orig[ind],neigh[ind]\n",
    "    \n",
    "    # Count\n",
    "    changes = np.arange(1,neigh.size)[neigh[1:]!=neigh[:-1]]\n",
    "    changes = np.append(np.insert(changes,0,0),neigh.size)\n",
    "    return orig,changes\n",
    "\n",
    "def FastMarching(update,u0,args):\n",
    "    \n",
    "    # Compute the reverse neighbors\n",
    "    _,offsets,_ = args\n",
    "    rev,chg = ReverseNeighbors(u0.shape,np.stack((offsets,-offsets),axis=1))\n",
    "\n",
    "    # Find the seeds\n",
    "    seeds = u0<np.inf\n",
    "    heap=[(value,index) for value,index in zip(u0[seeds],np.arange(u0.size)[seeds.flatten()]) ]\n",
    "    heapq.heapify(heap)\n",
    "    \n",
    "    # Run the Dijkstra-like method\n",
    "    accepted = np.full(u0.shape,False).flatten()\n",
    "    u = u0.copy().flatten()\n",
    "    niter=0\n",
    "    while heap:\n",
    "        # Find the non-accepted point with smallest value\n",
    "        value,index = heapq.heappop(heap)\n",
    "        if value > u[index]: continue\n",
    "        accepted[index]=True\n",
    "        # Update the neighbors\n",
    "        for index2 in rev[chg[index]:chg[index+1]]:\n",
    "            if accepted[index2]: continue\n",
    "            value2 = update(u.reshape(u0.shape),*args,where=np.unravel_index(index2,u0.shape))\n",
    "            niter+=1\n",
    "            if value2 < u[index2]:\n",
    "                u[index2]=value2\n",
    "                heapq.heappush(heap,(value2,index2))\n",
    "    return u.reshape(u0.shape),niter/u0.size"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Note on execution time.** Again, the computation time observed here is not representative of what is obtained in a compiled language, compatible with sequential execution on a mutable state."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 4.21 s, sys: 11.7 ms, total: 4.22 s\n",
      "Wall time: 4.22 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "u0=np.where(np.isnan(bc),np.inf,bc)\n",
    "solution,nupdate = FastMarching(Update,u0,(coefs,offsets,gridScale))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The number of updates per point is greatly reduced w.r.t. the fast sweeping method (and global iteration as well). In some implementations, this can be counterbalanced by the cost of maintaining a priority queue."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average number of updates per point : 2.9219530949634756\n"
     ]
    }
   ],
   "source": [
    "print(\"Average number of updates per point :\", nupdate)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.axis('equal')\n",
    "plt.contourf(X0,X1,solution);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Despite the smaller number of updates per point, the system is exactly solved."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Max residue : 1.7985612998927536e-14\n"
     ]
    }
   ],
   "source": [
    "residue = Scheme(solution,coefs,offsets,gridScale)\n",
    "print(\"Max residue :\",LInfNorm(residue))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Anisotropic metric\n",
    "\n",
    "The numerical schemes above presented apply without modification to non-constant, anisotropic Riemannian metrics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Define the square [-1,1]^2, sampled on a cartesian grid\n",
    "aX0 = np.linspace(-1,1,51); aX1 = aX0\n",
    "gridScale=aX0[1]-aX0[0]\n",
    "X0,X1 = np.meshgrid(aX0,aX1,indexing='ij')\n",
    "\n",
    "# Generate the metric\n",
    "eig1 = np.stack((np.full(X0.shape,1.),(np.pi/2)*np.cos(2*np.pi*X0)))\n",
    "eig1 /= scipy.linalg.norm(eig1,axis=0) \n",
    "eig2 = np.stack( (eig1[1],-eig1[0]) ) # Rotate eig1 by pi/2\n",
    "lambda1, lambda2 = 0.8, 0.2\n",
    "metric = lambda1**-2*lp.outer_self(eig1) + lambda2**-2*lp.outer_self(eig2)\n",
    "\n",
    "# Decompose the tensors dual to the Riemannian metric\n",
    "coefs, offsets = Selling.Decomposition(lp.inverse(metric))\n",
    "coefs[:,np.logical_not(np.isnan(bc))] = np.nan"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 105 ms, sys: 4.15 ms, total: 109 ms\n",
      "Wall time: 108 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "u0=np.where(np.isnan(bc),np.inf,bc)\n",
    "solution_Global,nupdate_Global = GlobalIteration(Update,u0,(coefs,offsets,gridScale))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.axis('equal')\n",
    "plt.contourf(X0,X1,solution_Global);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 1.62 s, sys: 14.8 ms, total: 1.63 s\n",
      "Wall time: 1.63 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "u0=np.where(np.isnan(bc),np.inf,bc)\n",
    "solution_Sweep,nupdate_Sweep = SweepIteration(Update,u0,(coefs,offsets,gridScale))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 4.93 s, sys: 36.7 ms, total: 4.97 s\n",
      "Wall time: 4.98 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "u0=np.where(np.isnan(bc),np.inf,bc)\n",
    "solution_FM,nupdate_FM = FastMarching(Update,u0,(coefs,offsets,gridScale))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As before, the number of updates per point is largest for global iteration, and smallest for the fast marching method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of updates per point.\n",
      "Global iteration : 65\n",
      "Fast sweeping : 48\n",
      "Fast marching : 3.021914648212226\n"
     ]
    }
   ],
   "source": [
    "print(\"Number of updates per point.\")\n",
    "print(\"Global iteration :\",nupdate_Global)\n",
    "print(\"Fast sweeping :\",nupdate_Sweep)\n",
    "print(\"Fast marching :\",nupdate_FM)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The residue of the fast marching method is zero, up to numerical precision. In constrast, the residue of the fast sweeping method and of the global iteration method is expected to be of the order of the prescribed tolerance $\\epsilon$, here defaulted to $\\epsilon = 1e-6$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Numerical scheme residue.\n",
      "Global iteration : 2.930180383664549e-06\n",
      "Fast sweeping : 1.261707627264741e-09\n",
      "Fast marching : 1.9761969838327786e-14\n"
     ]
    }
   ],
   "source": [
    "residue_Global,residue_Sweep,residue_FM = (LInfNorm(Scheme(solution,coefs,offsets,gridScale))\n",
    "                                           for solution in (solution_Global,solution_Sweep,solution_FM))\n",
    "print(\"Numerical scheme residue.\")\n",
    "print(\"Global iteration :\",residue_Global)\n",
    "print(\"Fast sweeping :\",residue_Sweep)\n",
    "print(\"Fast marching :\",residue_FM)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
